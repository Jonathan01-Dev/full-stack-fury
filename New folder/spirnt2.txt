
sprint 2

import socket
import threading
import os
import sys

class FileTransfer:
    def __init__(self, port=6001, save_dir="data/shared"):
        self.port = port
        self.save_dir = save_dir
        if not os.path.exists(self.save_dir):
            os.makedirs(self.save_dir)

    def start_server(self):
        """Lance le serveur TCP pour recevoir les fichiers."""
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('', self.port))
        server.listen(5)
        
        while True:
            client, addr = server.accept()
            threading.Thread(target=self._handle_receive, args=(client, addr), daemon=True).start()

    def _handle_receive(self, client_socket, addr):
        try:
            # 1. Lire l'en-t√™te (Nom | Taille)
            header = client_socket.recv(1024).decode().strip()
            if not header: return
            
            filename, filesize = header.split('|')
            filesize = int(filesize)
            print(f"\n[üì•] R√©ception de : {filename} ({filesize} octets)")

            # 2. Lire le contenu avec barre de progression
            file_path = os.path.join(self.save_dir, filename)
            received_bytes = 0
            
            with open(file_path, "wb") as f:
                while received_bytes < filesize:
                    chunk = client_socket.recv(4096)
                    if not chunk: break
                    f.write(chunk)
                    received_bytes += len(chunk)
                    self._draw_progress(received_bytes, filesize)
            
            print(f"\n‚úÖ Termin√© ! Sauvegard√© dans {self.save_dir}")

        except Exception as e:
            print(f"\n‚ùå Erreur r√©ception : {e}")
        finally:
            client_socket.close()

    def send_file(self, target_ip, file_path):
        """Envoie un fichier avec barre de progression."""
        if not os.path.exists(file_path):
            print(f"‚ùå Fichier introuvable.")
            return

        try:
            filename = os.path.basename(file_path)
            filesize = os.path.getsize(file_path)
            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client.connect((target_ip, self.port))

            # 1. Envoyer l'en-t√™te (Format: Nom|Taille)
            header = f"{filename}|{filesize}".ljust(1024)
            client.send(header.encode())

            # 2. Envoyer le contenu avec barre de progression
            sent_bytes = 0
            with open(file_path, "rb") as f:
                print(f"üì§ Envoi de {filename} √† {target_ip}...")
                while sent_bytes < filesize:
                    data = f.read(4096)
                    if not data: break
                    client.sendall(data)
                    sent_bytes += len(data)
                    self._draw_progress(sent_bytes, filesize)
            
            print(f"\n‚ú® Envoi termin√© !")
            client.close()
        except Exception as e:
            print(f"\n‚ùå √âchec de l'envoi : {e}")

    def _draw_progress(self, current, total):
        """Affiche une barre de progression simple dans la console."""
        width = 40
        percent = float(current) / total
        filled = int(width * percent)
        bar = "‚ñà" * filled + "-" * (width - filled)
        sys.stdout.write(f"\r|{bar}| {percent:.1%}")
        sys.stdout.flush()


git add .

git commit -m "feat: ajout du transfert TCP avec barre de progression"

git push origin main

Tes amis font : git pull origin main


sprint 3

2. Mise √† jour de src/crypto/keys.py


import os
from nacl.signing import SigningKey, VerifyKey
from nacl.encoding import HexEncoder
from nacl.exceptions import BadSignatureError

# Chemin vers la cl√© secr√®te
KEY_PATH = "data/keys/private.key"

def get_signing_key():
    """R√©cup√®re l'objet SigningKey (Cl√© Priv√©e) complet."""
    if not os.path.exists(KEY_PATH):
        # Cr√©er le dossier si besoin
        os.makedirs(os.path.dirname(KEY_PATH), exist_ok=True)
        # G√©n√©rer
        sk = SigningKey.generate()
        with open(KEY_PATH, "wb") as f:
            f.write(bytes(sk))
        return sk
    
    with open(KEY_PATH, "rb") as f:
        return SigningKey(f.read())

def get_node_id():
    """Retourne l'ID du n≈ìud (Cl√© publique en Hex)."""
    sk = get_signing_key()
    vk = sk.verify_key
    return vk.encode(encoder=HexEncoder).decode('utf-8')

# --- NOUVELLES FONCTIONS SPRINT 3 ---

def sign_file(file_data):
    """
    Signe le contenu d'un fichier avec la cl√© priv√©e du n≈ìud.
    Retourne la signature en format hexad√©cimal.
    """
    sk = get_signing_key()
    signature = sk.sign(file_data).signature
    return signature.hex()

def verify_file(file_data, signature_hex, sender_public_key_hex):
    """
    V√©rifie si un fichier a bien √©t√© sign√© par l'exp√©diteur.
    sender_public_key_hex est l'ID du n≈ìud qui a envoy√© le fichier.
    """
    try:
        # Reconstruire la cl√© de v√©rification √† partir de l'ID hexad√©cimal
        vk = VerifyKey(sender_public_key_hex, encoder=HexEncoder)
        # V√©rifier (l√®ve une erreur si la signature est fausse)
        vk.verify(file_data, bytes.fromhex(signature_hex))
        return True
    except (BadSignatureError, Exception):
        return False

if __name__ == "__main__":
    print(f"Mon identifiant Archipel est : {get_node_id()}")

src/network/transfer.py (Version Finale - Sprint 3)

import socket
import threading
import os
import sys
from src.crypto.keys import sign_file, verify_file

class FileTransfer:
    def __init__(self, port=6001, save_dir="data/shared"):
        self.port = port
        self.save_dir = save_dir
        if not os.path.exists(self.save_dir):
            os.makedirs(self.save_dir)

    def start_server(self):
        """Lance le serveur TCP pour recevoir et v√©rifier les fichiers."""
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('', self.port))
        server.listen(5)
        
        while True:
            client, addr = server.accept()
            threading.Thread(target=self._handle_receive, args=(client, addr), daemon=True).start()

    def _handle_receive(self, client_socket, addr):
        try:
            # 1. Lire l'en-t√™te (Format: Nom|Taille|Signature|ID_Exp√©diteur)
            header = client_socket.recv(2048).decode().strip()
            if not header: return
            
            filename, filesize, signature_hex, sender_id = header.split('|')
            filesize = int(filesize)
            
            print(f"\n[üì•] R√©ception de : {filename} ({filesize} octets)")
            print(f"[üõ°Ô∏è] Origine d√©clar√©e : {sender_id[:10]}...")

            # 2. Lire le contenu du fichier
            file_data = b""
            received_bytes = 0
            while received_bytes < filesize:
                chunk = client_socket.recv(4096)
                if not chunk: break
                file_data += chunk
                received_bytes += len(chunk)
                self._draw_progress(received_bytes, filesize)

            # 3. VERIFICATION SPRINT 3 : Est-ce que le fichier est authentique ?
            if verify_file(file_data, signature_hex, sender_id):
                file_path = os.path.join(self.save_dir, filename)
                with open(file_path, "wb") as f:
                    f.write(file_data)
                print(f"\n‚úÖ AUTHENTIQUE : Fichier sign√© par l'exp√©diteur et sauvegard√©.")
            else:
                print(f"\n‚ùå ALERTE S√âCURIT√â : La signature est invalide ! Fichier rejet√©.")

        except Exception as e:
            print(f"\n‚ùå Erreur r√©ception : {e}")
        finally:
            client_socket.close()

    def send_file(self, target_ip, file_path, my_id):
        """Signe et envoie un fichier √† un pair."""
        if not os.path.exists(file_path):
            print(f"‚ùå Fichier introuvable.")
            return

        try:
            filename = os.path.basename(file_path)
            with open(file_path, "rb") as f:
                file_data = f.read()
            
            filesize = len(file_data)
            
            # SPRINT 3 : Signer les donn√©es du fichier
            print(f"[‚úçÔ∏è] Signature du fichier en cours...")
            signature_hex = sign_file(file_data)

            client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client.connect((target_ip, self.port))

            # 1. Envoyer l'en-t√™te enrichi (Nom|Taille|Signature|ID)
            header = f"{filename}|{filesize}|{signature_hex}|{my_id}".ljust(2048)
            client.send(header.encode())

            # 2. Envoyer le contenu
            sent_bytes = 0
            print(f"üì§ Envoi de {filename} √† {target_ip}...")
            client.sendall(file_data) # On envoie tout car on l'a d√©j√† en m√©moire
            self._draw_progress(filesize, filesize)
            
            print(f"\n‚ú® Envoi termin√© et s√©curis√© !")
            client.close()
        except Exception as e:
            print(f"\n‚ùå √âchec de l'envoi : {e}")

    def _draw_progress(self, current, total):
        width = 40
        percent = float(current) / total
        filled = int(width * percent)
        bar = "‚ñà" * filled + "-" * (width - filled)
        sys.stdout.write(f"\r|{bar}| {percent:.1%}")
        sys.stdout.flush()



mise √† jour du fichier main.py

import threading
import time
import sys
import os
from src.crypto.keys import get_node_id
from src.network.peer_table import PeerTable
from src.network.discovery import Discovery
from src.network.transfer import FileTransfer 

def main():
    # 1. Obtenir l'identit√© (Cl√© Publique Hex)
    my_id = get_node_id()
    
    # Nettoyage de la console pour un d√©marrage propre
    os.system('cls' if os.name == 'nt' else 'clear')
    
    print(f"üöÄ SYST√àME ARCHIPEL : ACTIV√â")
    print(f"ID Local : {my_id}")
    print(f"Statut   : S√©curis√© (Sprint 3 - Signature Num√©rique)")
    print("-" * 50)

    # 2. Initialiser les modules
    table = PeerTable()
    disco = Discovery(my_id, table)
    transfer = FileTransfer()

    # 3. Lancer les threads r√©seau
    # Thread 1 : Broadcast UDP (Annonce de pr√©sence)
    threading.Thread(target=disco.broadcast, daemon=True).start()
    
    # Thread 2 : Listen UDP (D√©couverte des pairs)
    threading.Thread(target=disco.listen, daemon=True).start()
    
    # Thread 3 : Serveur TCP (R√©ception s√©curis√©e)
    threading.Thread(target=transfer.start_server, daemon=True).start()

    print("üì° Services de d√©couverte et de transfert en ligne.")

    # 4. Boucle d'interaction
    try:
        while True:
            print("\n" + "="*20 + " MENU " + "="*20)
            print("[1] Afficher la table des pairs (Voisins)")
            print("[2] Envoyer un fichier sign√©")
            print("[Q] Quitter le r√©seau")
            
            choix = input("\nAction > ").upper()

            if choix == "1":
                table.clean()
                table.display()
            
            elif choix == "2":
                # Affichage rapide des cibles disponibles
                table.clean()
                if not table.peers:
                    print("‚ö†Ô∏è Aucun voisin d√©tect√©. Attendez un peu ou v√©rifiez le Wi-Fi.")
                    continue
                
                print("\nVoisins disponibles :")
                for peer_id, info in table.peers.items():
                    print(f" - {info['ip']} (ID: {peer_id[:10]}...)")
                
                target_ip = input("\nIP du destinataire : ")
                path = input("Chemin du fichier (ex: test.txt) : ")
                
                # SPRINT 3 : On passe l'ID pour que le destinataire puisse nous identifier
                transfer.send_file(target_ip, path, my_id)
            
            elif choix == "Q":
                print("D√©connexion...")
                break
            
            else:
                print("Option invalide.")
            
            time.sleep(0.5)

    except KeyboardInterrupt:
        print("\nArr√™t forc√© par l'utilisateur.")
    finally:
        print("üëã Au revoir !")
        sys.exit()

if __name__ == "__main__":
    main()